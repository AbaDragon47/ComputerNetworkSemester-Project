"""
Networking Final Project Backend
coded by Aba Onumah, axo220029

This module implements a small room-based signaling / chat server using FastAPI and WebSockets.

Network model:
- HTTP endpoints (`/api/rooms`, `/api/rooms/{room_id}`) are used for room creation and
  basic metadata about rooms.
- A WebSocket endpoint (`/ws/{room_id}`) upgrades HTTP to a long-lived, bidirectional
  TCP connection. Each browser tab/device maintains one WebSocket per room.
- All WebSocket messages are scoped by `room_id` and are broadcast to every other
  client in the same room.

Message format on the WebSocket:
- System messages (JSON strings generated by the server):
    {"type": "system", "event": "welcome", "client_id": "...", "room_id": "..."}
    {"type": "system", "event": "join",    "client_id": "..."}
    {"type": "system", "event": "leave",   "client_id": "..."}
  The frontend can treat these specially to show status like
  "Peer joined" / "Peer left" instead of displaying them as chat text.

- Application / chat messages:
    For now, any text sent by clients is relayed as-is to the other peers.
    This keeps the backend "dumb" and makes it easy to layer higher-level
    protocols (e.g., WebRTC signaling) on top of the same channel later.

All state is maintained in memory and is intentionally ephemeral: when the server
restarts, all rooms and connections are lost. This is acceptable for a demo and
keeps the implementation focused on networking rather than persistence.
"""

import secrets
import json
import uuid
from typing import Dict, Set

from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware

# FastAPI app instance; Uvicorn serves this ASGI application.
app = FastAPI(
    title="Networking Final Project Backend",
    description="Room-based data sharing over WebSockets",
    version="0.1.0",
)

# CORS middleware:
# During development the frontend is served from a different origin/port (e.g. 5500),
# so we allow cross-origin requests and WebSocket upgrades from any origin.
# In a production deployment this should be restricted.
# Allow frontend dev on localhost (adjust origins later if needed)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # for dev; you can restrict later
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# room_id -> set of connected websockets
#
# This is the core in-memory data structure that represents "who is in which room".
# We use a set so membership checks and removals are O(1), and because a given
# WebSocket should not appear twice in the same room.
rooms: Dict[str, Set[WebSocket]] = {}

# websocket -> client_id
#
# Each WebSocket connection is given a stable, globally unique client_id (UUID).
# We keep this mapping so that when messages arrive we can log and refer to
# the sender without leaking their IP address directly into the chat layer.
client_ids: Dict[WebSocket, str] = {}


@app.get("/")
async def root():
    """
    Health-check endpoint.

    This is primarily used as a quick sanity check that the backend is running.
    The grader (or our own scripts) can call this endpoint and expect a simple
    JSON response without needing to open a WebSocket.
    """
    return {"status": "ok", "message": "Backend is running"}


@app.post("/api/rooms")
async def create_room():
    """
    Create a new logical "room" and return its ID.

    We generate a short, random hex string using secrets.token_hex so that:
    - Room IDs are hard to guess (good for semi-private sessions),
    - But still short enough to be shared manually or via a URL.

    The frontend calls this endpoint when the user clicks "Create Room" and
    then encodes the returned room_id into the URL (e.g. room.html?room=<room_id>).
    """
    # 6 hex chars = 3 bytes, e.g. "a3f9c1"
    room_id = secrets.token_hex(3)

    # Initialize room in our in-memory dict
    rooms[room_id] = set()
    print(f"[INFO] Created room {room_id}")

    return {"room_id": room_id}


@app.get("/api/rooms/{room_id}")
async def get_room(room_id: str):
    """
    Simple endpoint to check if a room exists and how many clients are in it.

    This is useful for the frontend if someone clicks a shared link:
    it can call this before attempting to join to show a nicer error if the
    room_id is invalid or currently empty.
    """
    exists = room_id in rooms
    return {"room_id": room_id,
            "exists": exists,
            "num_clients": len(rooms.get(room_id, []))
            }


@app.websocket("/ws/{room_id}")
async def websocket_endpoint(websocket: WebSocket, room_id: str):
    """
    WebSocket endpoint for a given room.

    High-level algorithm:
    1. Accept the WebSocket handshake.
    2. Ensure the target room exists (auto-create if needed).
    3. Generate a unique client_id and register this connection in our
       rooms/client_ids maps.
    4. Send a "welcome" system message back to this client.
    5. Broadcast a "join" system message to the rest of the room.
    6. Enter a receive loop that:
       - Waits for messages from this client,
       - Logs them,
       - Broadcasts them to the other clients in the same room.
    7. On disconnect, delegate cleanup + "leave" notifications to handle_disconnect().
    """
    await websocket.accept()

    # The client.host and client.port pair identifies the network endpoint for this
    # TCP connection. We log it to demonstrate that multiple *distinct* network
    # entities are connecting to the server (important for the course requirement).
    client_host = websocket.client.host
    client_port = websocket.client.port
    print(f"[INFO] WS connection from {client_host}:{client_port} to room {room_id}")


    # If someone joins a room through a link before /api/rooms was called,
    # we create the room on the fly. This makes the system more robust to
    # users skipping the "Create Room" button and directly sharing URLs.
    if room_id not in rooms:
        rooms[room_id] = set()

    rooms[room_id].add(websocket)
    # Assign a globally unique client_id to this connection so we can
    # identify it in logs and "system" messages without exposing raw IPs.
    client_id = str(uuid.uuid4())
    client_ids[websocket] = client_id

    print(
            f"[INFO] New WS from {client_host}:{client_port} "
            f"-> client_id={client_id} joined room {room_id}. "
            f"Total: {len(rooms[room_id])}"
    )

    #  Tell this client about its identity and room in a structured way.
    # The frontend uses this to cache client_id if it wants, but even if
    # it ignores it, this message also doubles as confirmation that the
    # connection is fully established.
    await websocket.send_text(json.dumps({
        "type": "system",
        "event": "welcome",
        "client_id": client_id,
        "room_id": room_id,
    }))

    # optional: notify others that someone joined
    # We mark this as a "system" message so the frontend can render it as
    # a status line (e.g., "Peer joined the room") instead of chat text.
    await broadcast_room(room_id, 
                         json.dumps({
                             "type": "system",
                             "event": "join",
                             "client_id": client_id,
                         }),
                           sender=websocket)   


    try:
        # Main receive loop: this keeps the WebSocket alive until the client
        # disconnects. Any text message we receive here is considered an
        # application-level message and is forwarded to the rest of the room.
        while True:
            data = await websocket.receive_text()
            print(f"[MSG] room={room_id} from={client_id}: {data!r}")
            # Here you can later parse JSON, enforce "type", "sender", etc.
            # For now, just broadcast raw text to others in the same room.
            await broadcast_room(room_id, data, sender=websocket)
    except WebSocketDisconnect:
        # When the client closes the connection (tab closed, network drop, etc),
        # FastAPI raises WebSocketDisconnect. We centralize cleanup logic in
        # handle_disconnect() so that all paths are consistent.
        await handle_disconnect(websocket, room_id, client_id)

async def handle_disconnect(websocket: WebSocket, room_id: str, client_id: str):
    """
    Cleanup + notify others when a client disconnects.

    Responsibilities:
    - Remove the WebSocket from the room's set.
    - Remove its client_id mapping so we don't leak memory.
    - Log the new room size for debugging/evaluation.
    - Broadcast a "leave" system message to the remaining peers.
    - If the room becomes empty, delete the room entirely so that future
      calls to /api/rooms reflect the up-to-date state.
    """
    # Remove from room + client_ids map
    if room_id in rooms and websocket in rooms[room_id]:
        rooms[room_id].remove(websocket)
    client_ids.pop(websocket, None)

    remaining = len(rooms.get(room_id, []))
    print(
        f"[INFO] Client {client_id} disconnected from room {room_id}. "
        f"Remaining clients: {remaining}"
    )

    # Notify the rest of the rooms that this client has left so the UI
    # can display an appropriate status message.
    if room_id in rooms:
        await broadcast_room(
            room_id,
            json.dumps({
                "type": "system",
                "event": "leave",
                "client_id": client_id,
            }),
        )

        # If room is empty, clean it up
        if not rooms[room_id]:
            del rooms[room_id]
            print(f"[INFO] Room {room_id} deleted (empty after disconnect).")


async def broadcast_room(room_id: str, message: str, sender: WebSocket | None = None):
    """
    Send `message` to all clients in `room_id` except the optional sender.

    Design choice:
    - We keep broadcasting logic in a separate function so that it can be reused
      from both the main receive loop and system events (join/leave).
    - We attempt to send to every WebSocket in the room; if a send fails, we
      mark that socket as "dead" and clean it up to prevent memory leaks.
    """
    if room_id not in rooms:
        return

    dead_sockets = []

    for ws in rooms[room_id]:
        if ws is sender:
            # Do not echo messages back to the original sender; the sender
            # typically shows their own message immediately in the UI.
            continue
        try:
            await ws.send_text(message)
        except Exception:
            # If send_text fails, the connection is no longer usable.
            # We defer removal until after the loop to avoid modifying
            # the set while iterating
            dead_sockets.append(ws)

    # Clean up any dead connections
    for ws in dead_sockets:
        rooms[room_id].remove(ws)

    # If the room is now empty, delete the entry entirely.
    if not rooms[room_id]:
        del rooms[room_id]
        print(f"[INFO] Room {room_id} deleted (empty in broadcast).")

# To run (Windows native for multi-device demo), from the backend/ directory:
#   .venv\Scripts\activate
#   uvicorn main:app --host 0.0.0.0 --port 8000 --reload
#
# The --host and --port flags are important for allowing phones/laptops on the
# same LAN to connect to this backend using the machine's private IP.